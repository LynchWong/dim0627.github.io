<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Unresolved </title>
    <link>http://yet.unresolved.xyz/tags/clojure/</link>
    <language>en-us</language>
    <author>Daisuke Tsuji</author>
    <rights>(C) 2015</rights>
    <updated>2015-01-25 20:52:46 &#43;0900 JST</updated>

    
      
        <item>
          <title>SlackAPIで遊ぶ</title>
          <link>http://yet.unresolved.xyz/blog/2015/01/25/play-slack-api/</link>
          <pubDate>Sun, 25 Jan 2015 20:52:46 JST</pubDate>
          <author>Daisuke Tsuji</author>
          <guid>http://yet.unresolved.xyz/blog/2015/01/25/play-slack-api/</guid>
          <description>

&lt;p&gt;最近
&lt;a href=&#34;http://www.amazon.co.jp/gp/product/4797328355/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=4797328355&amp;linkCode=as2&amp;tag=unresolved-22&#34;&gt;ふつうのLinuxプログラミング&lt;/a&gt;&lt;img src=&#34;http://ir-jp.amazon-adsystem.com/e/ir?t=unresolved-22&amp;l=as2&amp;o=9&amp;a=4797328355&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important; display:inline;&#34; /&gt;を読んでます。知りたいことが書かれてて楽しい！&lt;/p&gt;

&lt;p&gt;でもずっと本読むのは飽きるよね。なのでSlackのAPIとか触ってみる。&lt;/p&gt;

&lt;h2 id=&#34;slackapiの種類:4800906b877996c3dc902a23f48b0c5e&#34;&gt;SlackAPIの種類&lt;/h2&gt;

&lt;p&gt;SlackのAPIはいくつか種類があるんだね、トリガになるパターンが違うのかな？&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;01&lt;/sub&gt;/24時点でのAPIをまとめてみる。&lt;/p&gt;

&lt;h3 id=&#34;slack-web-api-https-api-slack-com-web:4800906b877996c3dc902a23f48b0c5e&#34;&gt;&lt;a href=&#34;https://api.slack.com/web&#34;&gt;Slack Web API&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;指定したチャンネルの履歴とかユーザの一覧とか、Slackの情報を取得出来る。&lt;/p&gt;

&lt;p&gt;Web APIなので、URLベースでの取得。&lt;/p&gt;

&lt;h3 id=&#34;real-time-messaging-api-https-api-slack-com-rtm:4800906b877996c3dc902a23f48b0c5e&#34;&gt;&lt;a href=&#34;https://api.slack.com/rtm&#34;&gt;Real Time Messaging API&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Web Socketベースのリアルタイムチャット機能を提供する？&lt;/p&gt;

&lt;p&gt;bot userがどうのこうのっていうのがよくわからない。&lt;/p&gt;

&lt;h3 id=&#34;slackbot-remote-control-https-api-slack-com-slackbot:4800906b877996c3dc902a23f48b0c5e&#34;&gt;&lt;a href=&#34;https://api.slack.com/slackbot&#34;&gt;Slackbot Remote Control&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;SlackBotに喋らせたり出来る。ちょうかわいい。&lt;/p&gt;

&lt;h3 id=&#34;incoming-webhooks-https-api-slack-com-incoming-webhooks:4800906b877996c3dc902a23f48b0c5e&#34;&gt;&lt;a href=&#34;https://api.slack.com/incoming-webhooks&#34;&gt;Incoming Webhooks&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;指定したチャンネルに投稿出来る。&lt;/p&gt;

&lt;h3 id=&#34;outgoing-webhooks-https-api-slack-com-outgoing-webhooks:4800906b877996c3dc902a23f48b0c5e&#34;&gt;&lt;a href=&#34;https://api.slack.com/outgoing-webhooks&#34;&gt;Outgoing Webhooks&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;指定した単語に応じて指定したURLを叩ける。&lt;/p&gt;

&lt;h3 id=&#34;slash-commands-https-api-slack-com-slash-commands:4800906b877996c3dc902a23f48b0c5e&#34;&gt;&lt;a href=&#34;https://api.slack.com/slash-commands&#34;&gt;Slash Commands&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;指定したスラッシュで始まる単語に応じてURLを叩けて、レスポンスがそのまま投稿される。&lt;/p&gt;

&lt;p&gt;今回は発言のタイミングで発火する&lt;a href=&#34;https://api.slack.com/slash-commands&#34;&gt;Slash Commands&lt;/a&gt;を使ってみようかな！&lt;/p&gt;

&lt;h2 id=&#34;スラッシュコマンドの追加:4800906b877996c3dc902a23f48b0c5e&#34;&gt;スラッシュコマンドの追加&lt;/h2&gt;

&lt;p&gt;ここから新しくコマンドの追加が出来る。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://my.slack.com/services/new/slash-commands&#34;&gt;https://my.slack.com/services/new/slash-commands&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://yet.unresolved.xyz/images/2015-01-25/new_command.png&#34;&gt;&lt;img src=&#34;http://yet.unresolved.xyz/images/2015-01-25/new_command.png&#34; class=&#34;image&#34; alt=&#34;new_command&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;herokuでさくっとHello World作って試してみようかな。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://yet.unresolved.xyz/images/2015-01-25/command_test.png&#34;&gt;&lt;img src=&#34;http://yet.unresolved.xyz/images/2015-01-25/command_test.png&#34; class=&#34;image&#34; alt=&#34;command_test&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;おお、出るじゃん！でも&lt;code&gt;Only you can see this message&lt;/code&gt;って出てる、オレしか見れないんだね。&lt;/p&gt;

&lt;h2 id=&#34;replを作ろう:4800906b877996c3dc902a23f48b0c5e&#34;&gt;REPLを作ろう&lt;/h2&gt;

&lt;p&gt;なんかSlack上でプログラム打つと実行結果が返ってくるみたいなやつ誰かが作ってたよね？&lt;/p&gt;

&lt;p&gt;あれ調べても出ないんだけどなんでなんだろう。&lt;/p&gt;

&lt;p&gt;まあとりあえず、作ったばっかの&lt;a href=&#34;https://paiza.io/&#34;&gt;paiza.IO&lt;/a&gt;のAPIを叩くあれを導入してみる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://yet.unresolved.xyz/blog/2015/01/25/make-repl-using-the-paizaio/&#34;&gt;paiza.ioのAPIを使ってreplを作る | Unresolved&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;スラッシュコマンドAPIは&lt;code&gt;/command args&lt;/code&gt;って感じにやると、指定したURLに&lt;code&gt;text&lt;/code&gt;ってパラメータ名で&lt;code&gt;args&lt;/code&gt;が飛ばされるみたい。&lt;/p&gt;

&lt;p&gt;なので&lt;code&gt;/repl ruby:p &amp;quot;hello&amp;quot;&lt;/code&gt;って感じで実行できるようにしようかな。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://yet.unresolved.xyz/images/2015-01-25/slack_repl.png&#34;&gt;&lt;img src=&#34;http://yet.unresolved.xyz/images/2015-01-25/slack_repl.png&#34; class=&#34;image&#34; alt=&#34;slack_repl&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;別にURL出してもいいんだけど・・・。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;compojure&lt;/code&gt;のルーティングはこんな。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defroutes app-routes
  (GET &amp;quot;/&amp;quot; [text]
       (if (empty? text) &amp;quot;Invalid input.&amp;quot;
         (let [[language source] (seq (.split text &amp;quot;:&amp;quot;))]
           (str &amp;quot;[&amp;quot; language &amp;quot;] &amp;quot; source &amp;quot;\r\n-&amp;gt; &amp;quot; (repl language source))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;実行してみる:4800906b877996c3dc902a23f48b0c5e&#34;&gt;実行してみる&lt;/h2&gt;

&lt;p&gt;さっき書いた通り、&lt;code&gt;/repl ruby:p &amp;quot;hello&amp;quot;&lt;/code&gt;でいけるかな。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://yet.unresolved.xyz/images/2015-01-25/slack_repl_run.png&#34;&gt;&lt;img src=&#34;http://yet.unresolved.xyz/images/2015-01-25/slack_repl_run.png&#34; class=&#34;image&#34; alt=&#34;slack_repl_run&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;いけるやん！&lt;/p&gt;

&lt;p&gt;Javaだる！&lt;/p&gt;

&lt;h2 id=&#34;コードの全貌:4800906b877996c3dc902a23f48b0c5e&#34;&gt;コードの全貌&lt;/h2&gt;

&lt;p&gt;やばい&lt;code&gt;project.clj&lt;/code&gt;とかherokuから持ってきたままだしリファクタリングもしてないし超適当だ&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/dim0627/slack_repl&#34;&gt;dim0627/slack_repl&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>paiza.ioのAPIを使ってreplを作る</title>
          <link>http://yet.unresolved.xyz/blog/2015/01/25/make-repl-using-the-paizaio/</link>
          <pubDate>Sun, 25 Jan 2015 00:58:15 JST</pubDate>
          <author>Daisuke Tsuji</author>
          <guid>http://yet.unresolved.xyz/blog/2015/01/25/make-repl-using-the-paizaio/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;http://paiza.jp/&#34;&gt;paiza&lt;/a&gt;が面白いAPIを公開してたから、そのうち使ってみたいと思ってたんだよね。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://paiza.io/&#34;&gt;ブラウザでプログラミング・実行ができる「オンライン実行環境」| paiza.IO&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ちょっとSlackAPIで使ってみたいからこの機会に軽くだけ触ってみる。&lt;/p&gt;

&lt;h2 id=&#34;何が出来る:263a1859984e07d4bd8e496e6113e0fc&#34;&gt;何が出来る？&lt;/h2&gt;

&lt;p&gt;たくさんの言語のREPLが使える！すごい！&lt;/p&gt;

&lt;p&gt;ただ、コンパイル言語はそんな気軽に使える感じではないみたい。&lt;/p&gt;

&lt;p&gt;例えばJavaで言えば、&lt;code&gt;System.out.println(&amp;quot;Hello&amp;quot;);&lt;/code&gt;だけじゃなくてクラス定義から含めなきゃいけないみたいに。&lt;/p&gt;

&lt;h2 id=&#34;どうやって使う:263a1859984e07d4bd8e496e6113e0fc&#34;&gt;どうやって使う？&lt;/h2&gt;

&lt;p&gt;どうやら&lt;a href=&#34;http://swagger.io/&#34;&gt;Swagger&lt;/a&gt;っていうOSSを使ってるみたい。&lt;/p&gt;

&lt;p&gt;paiza.io上でのデモも使える。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://api.paiza.io/docs/swagger/#!/runners/&#34;&gt;Swagger UI&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;なんか動かないなと思ったら&lt;code&gt;https&lt;/code&gt;で&lt;code&gt;http&lt;/code&gt;のリソースを参照してたみたいで、ブロックされてた。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Mixed Content: The page at &#39;https://api.paiza.io/docs/swagger/#!/runners/&#39; was loaded over HTTPS, but requested an insecure XMLHttpRequest endpoint &#39;http://api.paiza.io/docs/swagger-docs/runners.json?api_key=guest&#39;. This request has been blocked; the content must be served over HTTPS.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;評価パターンは3つあるみたい。&lt;/p&gt;

&lt;h3 id=&#34;runners-create:263a1859984e07d4bd8e496e6113e0fc&#34;&gt;runners/create&lt;/h3&gt;

&lt;p&gt;コードの実行が出来る。&lt;/p&gt;

&lt;p&gt;レスポンスに&lt;code&gt;id&lt;/code&gt;と&lt;code&gt;status&lt;/code&gt;が返ってきて、この&lt;code&gt;id&lt;/code&gt;を使って実行結果とかを見る。&lt;/p&gt;

&lt;h3 id=&#34;runners-get-status:263a1859984e07d4bd8e496e6113e0fc&#34;&gt;runners/get_status&lt;/h3&gt;

&lt;p&gt;実行結果を見ることが出来る。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;completed&lt;/code&gt;とかそういうレベル。&lt;/p&gt;

&lt;h3 id=&#34;runners-get-details:263a1859984e07d4bd8e496e6113e0fc&#34;&gt;runners/get_details&lt;/h3&gt;

&lt;p&gt;実行結果として出力された値とかを見ることが出来る。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;runners/create&lt;/code&gt;で実行して&lt;code&gt;runners/get_details&lt;/code&gt;で結果を見る感じ。&lt;/p&gt;

&lt;h2 id=&#34;clojureから叩こう:263a1859984e07d4bd8e496e6113e0fc&#34;&gt;Clojureから叩こう&lt;/h2&gt;

&lt;p&gt;使い方はわかったしURL叩けば済む話だしさっさと作っちゃう。&lt;/p&gt;

&lt;p&gt;HTTPアクセスはJavaのクラス使おうかなと思ったけど、&lt;a href=&#34;https://github.com/dakrone/clj-http&#34;&gt;dakrone/clj-http&lt;/a&gt;っていうすごく優秀！なライブラリがあったのでこれを使います。&lt;/p&gt;

&lt;p&gt;まず&lt;code&gt;runners/get/create&lt;/code&gt;を実行するところ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn repl [language source]
  (let [run-id (-&amp;gt; (httpc/post &amp;quot;http://api.paiza.io/runners/create&amp;quot;
                               {:form-params {:source_code source
                                              :language language
                                              :api_key &amp;quot;guest&amp;quot;}
                                :as :json})
                   :body
                   :id)]
    (get-res run-id)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;get-res&lt;/code&gt;は後述。&lt;code&gt;get_details&lt;/code&gt;を実行するための関数。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;api_key&lt;/code&gt;ってこれでいいのだろうか。&lt;/p&gt;

&lt;p&gt;とりあえず動いてはいる！&lt;/p&gt;

&lt;p&gt;実行結果の取得はこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn get-res [run-id]
  (let [res (httpc/get (str &amp;quot;http://api.paiza.io/runners/get_details?id=&amp;quot; run-id &amp;quot;&amp;amp;api_key=guest&amp;quot;)
                           {:as :json})]
    (if (= (-&amp;gt; res :body :status) &amp;quot;running&amp;quot;)
      (do (Thread/sleep 100) (recur run-id))
      (-&amp;gt; res :body :stdout))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;runners/create&lt;/code&gt;を実行した直後は&lt;code&gt;status&lt;/code&gt;が&lt;code&gt;running&lt;/code&gt;なので、結果が取得できなかった。&lt;/p&gt;

&lt;p&gt;なのでスリープかけながら&lt;code&gt;running&lt;/code&gt;から外れるまで回す苦しい感じに・・・。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Clojureで新卒の女の子を射止めた話</title>
          <link>http://yet.unresolved.xyz/blog/2015/01/15/challenged-to-online-hackathon-of-paiza/</link>
          <pubDate>Thu, 15 Jan 2015 21:12:52 JST</pubDate>
          <author>Daisuke Tsuji</author>
          <guid>http://yet.unresolved.xyz/blog/2015/01/15/challenged-to-online-hackathon-of-paiza/</guid>
          <description>

&lt;p&gt;何やらプログラムの問題を解くと可愛い女の子とハネムーンにいけるとかいう企画を&lt;a href=&#34;http://paiza.jp/&#34;&gt;paiza&lt;/a&gt;が開催していたらしい。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://paiza.jp/poh/enkoi&#34;&gt;マンガ版「エンジニアでも恋がしたい！」〜転職初日にぶつかった女の子が同僚だった件〜｜paizaオンラインハッカソン4 Lite&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;会社の子からすすめられたのをずっと放置してたんだけど実際やってみたらなかなか面白かった。&lt;/p&gt;

&lt;p&gt;ちなみに実際に手に入るのはハネムーンじゃなくてねるねるねるねかラズパイだったらしい。&lt;/p&gt;

&lt;p&gt;ねるねるねるね・・・。&lt;/p&gt;

&lt;h2 id=&#34;problem-1:efdfd34ee3c2df97a027c1bccd3ee9c8&#34;&gt;Problem 1&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;在庫計算プログラムを作成してください。改行区切りで N 個の商品の各在庫数 S が入力されるので、その合計を出力して下さい。
解答次第でこの後のストーリーが変わります！！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;入力される値&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;入力は標準入力にて以下のフォーマットで与えられます。
N
S_1
S_2
・
・
S_N&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;条件&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;すべてのテストケースにおいて、以下の条件をみたします。
1 ≦ N ≦ 100
0 ≦ S_i ≦ 100&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;期待する出力&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;全ての商品の在庫数を足した数を出力してください。最後は改行し、余計な文字、空行を含んではいけません。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ふむふむ。&lt;/p&gt;

&lt;p&gt;ちなみにpaizaで使えるClojureのREPLはベータ版とのことで、変な挙動をするかも〜とのこと。&lt;/p&gt;

&lt;p&gt;入力の受け方はこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def in (line-seq (java.io.BufferedReader. *in*)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;オレの回答はこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def in (line-seq (java.io.BufferedReader. *in*)))
(defn p1 [] (reduce + (map #(Integer/parseInt %) (rest in))))
(print (p1))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;普通に&lt;code&gt;reduce&lt;/code&gt;で回しただけ。&lt;/p&gt;

&lt;h2 id=&#34;problem-2:efdfd34ee3c2df97a027c1bccd3ee9c8&#34;&gt;Problem 2&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;改行区切りで N 個の各商品の在庫数 S が入力されるので、その合計を出力して下さい。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;入力される値&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;入力は以下のフォーマットで与えられる。
N
T_1 S_1 P_1
T_2 S_2 P_2
・
・
・
T_N S_N P_N&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;条件&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;すべてのテストケースにおいて、以下の条件をみたします。
1 ≦ N ≦ 100
1 ≦ T_i ≦ 100
0 ≦ S_i ≦ 100
1 ≦ P_i ≦ 10,000&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;期待する出力&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在庫数を最低限必要な在庫数を満たすために必要な金額の合計を出力してください。
最後は改行し、余計な文字、空行を含んではいけません。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;問題文をよく読まずに解いて何度かミスりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def in (line-seq (java.io.BufferedReader. *in*)))
(defn p2 []
  (let [in (map #(.split % &amp;quot; &amp;quot;) (rest in))]
    (loop [l in res 0]
              (if (empty? l) res
                (let [[t s p] (map #(Integer/parseInt %) (first l))]
                  (recur (rest l) (+ res (if (&amp;gt; t s) (* (- t s) p) 0))))))))
(print (p2))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;単純に&lt;code&gt;if&lt;/code&gt;で条件かけながら再帰させた。&lt;/p&gt;

&lt;h2 id=&#34;problem-3:efdfd34ee3c2df97a027c1bccd3ee9c8&#34;&gt;Problem 3&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;区間合計点数の最大値を出力するプログラムを作成して、ゲームを完成させてください。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;入力される値&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;入力は以下のフォーマットで与えられる。
t n
m_1
m_2
m_3
&amp;hellip;
m_n&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;条件&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;すべてのテストケースにおいて、以下の条件をみたします。
1 ≦ t ≦ n ≦ 300,000
0 ≦ m_i ≦ 10,000&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;期待する出力&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;区間合計点数の最大値を出力せよ。
最後は改行し、余計な文字、空行を含んではならない。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;これはタイムアウトで何度も苦しんだ。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;partition-all&lt;/code&gt;で分割したものを&lt;code&gt;map&lt;/code&gt; &amp;amp; &lt;code&gt;reduce&lt;/code&gt;で合算して&lt;code&gt;apply&lt;/code&gt; &amp;amp; &lt;code&gt;max&lt;/code&gt;っていう何も考えなさすぎるロジックにしたのが悪いんだけど・・・。&lt;/p&gt;

&lt;p&gt;通ったのはこれ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def in (line-seq (java.io.BufferedReader. *in*)))
(defn p3 []
  (let [[len c] (map #(Integer/parseInt %) (.split (first in) &amp;quot; &amp;quot;))
        smr (reductions + (map #(Integer/parseInt %) (rest in)))]
    (if (= len c) (last smr)
      (loop [l smr sfxl (drop len l) res 0]
        (if (empty? sfxl) res
          (recur (rest l) (rest sfxl) (max (- (first sfxl) (first l)) res)))))))
(print (p3))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;無理だなーって&lt;a href=&#34;http://clojure.org/cheatsheet&#34;&gt;Clojure - cheatsheet&lt;/a&gt;見ながらぐだぐだしてたら&lt;code&gt;reductions&lt;/code&gt;でなんとかなりそうな事に気づいた。&lt;/p&gt;

&lt;p&gt;最初にどっと重い処理になるんじゃないかなと思って不安もあったけど、そんなことないのかな。無事通ったので良かったです。&lt;/p&gt;

&lt;p&gt;計算結果だしちゃえばあとは再帰させながら区間合計を算出 &amp;amp; 最大値を抽出でなんとか。&lt;/p&gt;

&lt;h2 id=&#34;やってみて:efdfd34ee3c2df97a027c1bccd3ee9c8&#34;&gt;やってみて&lt;/h2&gt;

&lt;p&gt;Clojureを始めてからずっと感じてる事だけど、アルゴリズムを考える力が弱いなあと思う。&lt;/p&gt;

&lt;p&gt;Webだとそれで乗り切れる部分が多かったんだろうけど、こういった問題を解いて地力をつけることも大切だなあと感じた。&lt;/p&gt;

&lt;p&gt;多分Clojureの界隈で有名な方々が組む答えはまた違うんだろうなあ。&lt;/p&gt;

&lt;p&gt;ぜひそういうのも見てみたいけど、調べてみたらあんまり解いてる人とか公開してる人がいない感じだった。&lt;/p&gt;

&lt;p&gt;ちなみにラズパイとかは期間が過ぎてるのでもらえません。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Clojureのテンプレートエンジンについて</title>
          <link>http://yet.unresolved.xyz/blog/2015/01/14/use-template-engine-in-clojure/</link>
          <pubDate>Wed, 14 Jan 2015 01:01:39 JST</pubDate>
          <author>Daisuke Tsuji</author>
          <guid>http://yet.unresolved.xyz/blog/2015/01/14/use-template-engine-in-clojure/</guid>
          <description>

&lt;p&gt;練習のためにClojureでいくつかのWebアプリを作ってみたんだけど、どの言語でもなんだかんだ手間になるテンプレートの扱いについてまとめてみる。&lt;/p&gt;

&lt;h2 id=&#34;enlive-https-github-com-cgrand-enlive:d03bd055194b84467476c0228f17c156&#34;&gt;&lt;a href=&#34;https://github.com/cgrand/enlive&#34;&gt;Enlive&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.amazon.co.jp/gp/product/B007Q4T040/ref=as_li_tf_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=B007Q4T040&amp;linkCode=as2&amp;tag=unresolved-22&#34;&gt;Clojure Programming&lt;/a&gt;&lt;img src=&#34;http://ir-jp.amazon-adsystem.com/e/ir?t=unresolved-22&amp;l=as2&amp;o=9&amp;a=B007Q4T040&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important; display:inline;&#34; /&gt;を執筆されたChristophe Grand氏のライブラリ。&lt;/p&gt;

&lt;p&gt;CSSのセレクタでバインドを行うという、すごく画期的な方法でテンプレート機能を実現させてる。&lt;/p&gt;

&lt;p&gt;例えばこんな感じでテンプレートのHTMLがあれば、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;This is a title placeholder&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうやってバインドできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(html/deftemplate main-template &amp;quot;templates/application.html&amp;quot;
  []
  [:head :title] (html/content &amp;quot;Enlive starter kit&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HTLMが素でかけるから、デザイナさんとの協業がすごく捗りそう。&lt;/p&gt;

&lt;p&gt;サンプルのHTMLをそのまま使って、Clojure側でサンプルの値を置き換えたりリピートさせたりすれば済んじゃう。&lt;/p&gt;

&lt;p&gt;今回は一人で使ったからそういう場面はなかったけど、サーバを起動しなくてもデザインが見れる &amp;amp; 直せるっていうのは便利な場面があるかなあと。&lt;/p&gt;

&lt;p&gt;ただ、結構CSSを書いたりしてるほうだけど、バインドの学習コストは意外と高いなと思った。&lt;/p&gt;

&lt;p&gt;効率的に手早くバインドさせるには、Enliveを使う想定のHTML構造にする必要がありそうな印象だった。&lt;/p&gt;

&lt;p&gt;覚えてしまえばものすごく活躍しそう。&lt;/p&gt;

&lt;h2 id=&#34;hiccup-https-github-com-weavejester-hiccup:d03bd055194b84467476c0228f17c156&#34;&gt;&lt;a href=&#34;https://github.com/weavejester/hiccup&#34;&gt;Hiccup&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/weavejester/compojure&#34;&gt;Compojure&lt;/a&gt;や&lt;a href=&#34;https://github.com/weavejester/environ&#34;&gt;Environ&lt;/a&gt;、&lt;a href=&#34;https://github.com/weavejester/lein-ring&#34;&gt;Ring&lt;/a&gt;などの作者、James Reeves氏のライブラリ。&lt;/p&gt;

&lt;p&gt;HTMLを完全にClojureでラップしてるので、ClojureだけでWebアプリを完結させられる。&lt;/p&gt;

&lt;p&gt;こんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (html [:script])
&amp;quot;&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;&amp;quot;
user=&amp;gt; (html [:p])
&amp;quot;&amp;lt;p /&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Clojureのコンパイルが走るので、タグの不整合(閉じタグがないとか)が一切起こらないっていうのは魅力だと思う。&lt;/p&gt;

&lt;p&gt;欠点を挙げるとすれば、改行なしでHTMLが出力されるからブラウザからソースを見るのが厳しい。ていうか無理。&lt;/p&gt;

&lt;p&gt;設定でなんとか出来るんだろうか？&lt;/p&gt;

&lt;p&gt;でもChromeの開発者ツールとか使えばフォーマットして表示してくれるし、全然クリティカルな問題じゃない。&lt;/p&gt;

&lt;p&gt;もう1点は、例えば広告のスクリプトみたいにコピペで貼り付けたい文字列とかの出力がちょっとめんどう。&lt;/p&gt;

&lt;p&gt;Hiccupの世界にただのタグを入れるのは見栄えも悪いし、オレはこんな感じで外だしすることで対応した。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def partial-ad-big (str &amp;quot;&amp;lt;script async src=&amp;quot;&amp;quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&amp;quot;&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;ins class=&amp;quot;&amp;quot;adsbygoogle&amp;quot;&amp;quot;
     style=&amp;quot;&amp;quot;display:inline-block;width:728px;height:90px&amp;quot;&amp;quot;
     data-ad-client=&amp;quot;&amp;quot;ca-pub-421xxxxxxxxxx76&amp;quot;&amp;quot;
     data-ad-slot=&amp;quot;&amp;quot;111xxxxxxxx42&amp;quot;&amp;quot;&amp;gt;&amp;lt;/ins&amp;gt;
&amp;lt;script&amp;gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&amp;lt;/script&amp;gt;&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;個人的にはHiccupのほうがさくっと理解できてさくっと書けたかな。&lt;/p&gt;

&lt;p&gt;ループ処理もClojureがかければそのまま書けちゃうし。&lt;/p&gt;

&lt;p&gt;ClojureとHTMLの親和性はすごく高いと思っていて、Hiccupはそれを最大限に活用することが出来てるなあという感じ。&lt;/p&gt;

&lt;p&gt;ある言語を他の言語でラップするのって再学習が必要だし非効率で嫌いだったんだけど、HiccupはHTMLの冗長さが減るし、学習する価値のあるライブラリだと思った。&lt;/p&gt;

&lt;p&gt;ゆくゆくはどっちもしっかり使えるようになりたい。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>ClojureのWebアプリをDocker &#43; Beanstalkで動かす</title>
          <link>http://yet.unresolved.xyz/blog/2014/12/31/clojure-on-docker-and-aws-beanstalk/</link>
          <pubDate>Wed, 31 Dec 2014 00:00:00 UTC</pubDate>
          <author>Daisuke Tsuji</author>
          <guid>http://yet.unresolved.xyz/blog/2014/12/31/clojure-on-docker-and-aws-beanstalk/</guid>
          <description>

&lt;p&gt;たぶんこういうのはドキュメント読んでもわからないので、とにかく一通りの流れを実践してみる。&lt;/p&gt;

&lt;h2 id=&#34;imageの取得:e7598df47e85c79be6b3ca007edb9ce3&#34;&gt;Imageの取得&lt;/h2&gt;

&lt;p&gt;面倒なので&lt;a href=&#34;https://hub.docker.com/account/signup/&#34;&gt;Docker Hub&lt;/a&gt;からClojureが動く環境を持ってくる。&lt;/p&gt;

&lt;p&gt;オフィシャルリポジトリとやらがあったので、それを使います。&lt;/p&gt;

&lt;p&gt;Leiningenとか一式が入ってるみたい。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://registry.hub.docker.com/_/clojure/&#34;&gt;clojure&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ローカルでの動作確認:e7598df47e85c79be6b3ca007edb9ce3&#34;&gt;ローカルでの動作確認&lt;/h2&gt;

&lt;p&gt;とりあえず世界に挨拶が出来るくらいのWebアプリを作っちゃおう。&lt;/p&gt;

&lt;p&gt;アプリ自体は重要じゃないので、とりあえずインタラクティブシェル上でちゃちゃっと作っちゃう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;b2d$  docker run -i -t clojure /bin/bash
root@e322a11f087d:/home# lein new compojure aws_webapp
Retrieving compojure/lein-template/0.4.1/lein-template-0.4.1.pom from clojars
Retrieving compojure/lein-template/0.4.1/lein-template-0.4.1.jar from clojars
root@e322a11f087d:/home# ls
aws_webapp
root@e322a11f087d:/home# cd aws_webapp/
root@e322a11f087d:/home/aws_webapp# ls
README.md  project.clj	resources  src	test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と思ったらcompojureテンプレート自体がすでにHello Worldを実装してた・・・。&lt;/p&gt;

&lt;p&gt;そのままサーバ起動しちゃうとこんな感じでブラウザの自動起動のとこでエラーしちゃうので、&lt;code&gt;lein ring server-headless&lt;/code&gt;で起動する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;root@e322a11f087d:/home/aws_webapp# lein ring server
2015-01-01 05:41:35.432:INFO:oejs.Server:jetty-7.6.8.v20121106
2015-01-01 05:41:35.486:INFO:oejs.AbstractConnector:Started SelectChannelConnector@0.0.0.0:3000
Started server on port 3000
Exception in thread &amp;quot;main&amp;quot; java.lang.InternalError: Can&#39;t connect to X11 window server using &#39;localhost:0.0&#39; as the value of the DISPLAY variable., compiling:(/tmp/form-init3570254627486988046.clj:1:72)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとはデーモンとして起動しちゃえばローカルでの確認が出来る。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;b2d$  docker run -d -t -p 3000:3000 clojure:aws /bin/bash -c &amp;quot;cd /home/aws_webapp; lein ring server-headless&amp;quot;
e9981a71589918791d52888a0cb503bea133611395be58574047cd498c9e6f76
b2d$  docker ps
CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS                    NAMES
e9981a715899        clojure:aws         &amp;quot;/bin/bash -c &#39;cd /h   4 seconds ago       Up 3 seconds        0.0.0.0:3000-&amp;gt;3000/tcp   backstabbing_colden
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起動しているのはboot2dockerの仮想マシン上なので、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;b2d$  boot2docker ip
192.168.59.103
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このIPの3000ポートに向けてアクセスすれば、&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://yet.unresolved.xyz/images/2015-01-01/webapp.png&#34;&gt;&lt;img src=&#34;http://yet.unresolved.xyz/images/2015-01-01/webapp.png&#34; class=&#34;image&#34; alt=&#34;webapp&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;見れます。&lt;/p&gt;

&lt;p&gt;ringのサーバは起動が遅いので&lt;code&gt;docker logs [names]&lt;/code&gt;で確認しながらやるとよい。&lt;/p&gt;

&lt;h2 id=&#34;elastic-beanstalkで動かす:e7598df47e85c79be6b3ca007edb9ce3&#34;&gt;Elastic Beanstalkで動かす&lt;/h2&gt;

&lt;p&gt;大事なことに気づいたんだけど、BeanstalkはDockerfileとか必要なファイル一式をまとめたzipをアップするらしい。&lt;/p&gt;

&lt;p&gt;そもそもソースもイメージに入れちゃうっていうのは考えとしておかしかったね。&lt;/p&gt;

&lt;p&gt;なのでwarを&lt;code&gt;ADD&lt;/code&gt;で置くのが理想的なのかな。&lt;/p&gt;

&lt;p&gt;今回は面倒なので、clojureでWebサーバを立ち上げられる&lt;code&gt;http-kit&lt;/code&gt;というライブラリを使ってやってみます。&lt;/p&gt;

&lt;p&gt;ちょうどBeanstalk用のDockerfileとかも用意してくれる&lt;a href=&#34;https://github.com/mrmcc3/beanstalk-docker-app&#34;&gt;mrmcc3/beanstalk-docker-app&lt;/a&gt;というテンプレートがあったので、これを使わせてもらうことに。&lt;/p&gt;

&lt;h3 id=&#34;mrmcc3-beanstalk-docker-appでwebアプリを構築する:e7598df47e85c79be6b3ca007edb9ce3&#34;&gt;mrmcc3/beanstalk-docker-appでWebアプリを構築する&lt;/h3&gt;

&lt;p&gt;何はともあれ&lt;code&gt;new&lt;/code&gt;して作り直し。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;temp$ lein new beanstalk-docker-app superapp
Generating clojure app for AWS Beanstalk and docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じで作られる。&lt;/p&gt;

&lt;p&gt;jarとかは&lt;code&gt;lein uberjar&lt;/code&gt;で作らなきゃダメかも。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;.
|-- Dockerfile
|-- Dockerrun.aws.json
|-- project.clj
|-- src
|   `-- superapp
|       `-- main.clj
`-- target
    |-- classes
    |   |-- META-INF
    |   |-- clojure
    |   |-- org
    |   `-- superapp
    |-- production.jar
    |-- stale
    |   `-- extract-native.dependencies
    |-- superapp-0.1.0.jar
    `-- superapp-0.1.0.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dockerfileはこんな。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-docker&#34;&gt;# Dockerfile for clojure apps on AWS Elastic Beanstalk
# v0.0.1

FROM dockerfile/java
MAINTAINER Michael McClintock, mrmcc3@gmail.com
ADD target/production.jar /root/
EXPOSE 8080
CMD [&amp;quot;java&amp;quot;, &amp;quot;-jar&amp;quot;, &amp;quot;/root/production.jar&amp;quot;]

# SUPPORT JVM OPTS ?
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;動作確認:e7598df47e85c79be6b3ca007edb9ce3&#34;&gt;動作確認&lt;/h3&gt;

&lt;p&gt;ローカルでの動作確認はこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;superapp$ java -jar target/production.jar
13:33:07.705 [main] INFO  superapp.main - starting superapp
13:33:07.710 [main] INFO  superapp.main - serving status message
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://yet.unresolved.xyz/images/2015-01-01/beanstalkDockerApp.png&#34;&gt;&lt;img src=&#34;http://yet.unresolved.xyz/images/2015-01-01/beanstalkDockerApp.png&#34; class=&#34;image&#34; alt=&#34;beanstalkDockerApp&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;デプロイ:e7598df47e85c79be6b3ca007edb9ce3&#34;&gt;デプロイ&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;lein zip&lt;/code&gt;でBeanstalk用のzipが&lt;code&gt;target&lt;/code&gt;配下に作成されるので、それをアップロード。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Dockerrun.aws.json&lt;/code&gt;でポートの指定とかやってるんだけど、こいつもzipに入れてしまうとtimeoutしてしまった。&lt;/p&gt;

&lt;p&gt;まあそれでも動くんだけどちょっと気持ち悪いので除外。&lt;/p&gt;

&lt;p&gt;ポートの指定やらはDockerfileでやってるので問題なく動きます。&lt;/p&gt;

&lt;p&gt;デプロイはこんな感じで成功。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://yet.unresolved.xyz/images/2015-01-01/deploy.png&#34;&gt;&lt;img src=&#34;http://yet.unresolved.xyz/images/2015-01-01/deploy.png&#34; class=&#34;image&#34; alt=&#34;deploy&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;しかしデプロイは結構時間かかるなー。&lt;/p&gt;

&lt;p&gt;Javaの起動とかライブラリのダウンロードで食ってるのかな・・・。&lt;/p&gt;

&lt;h2 id=&#34;参考にさせて頂きました:e7598df47e85c79be6b3ca007edb9ce3&#34;&gt;参考にさせて頂きました&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://wslash.com/?p=5584&#34;&gt;Dockerを勉強するための、Docker解説記事のまとめ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://knowledge.sakura.ad.jp/tech/1811/&#34;&gt;これから始める「DockerでかんたんLAMP環境 for CentOS」&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://nudaygames.squarespace.com/blog/2014/12/13/clojure-websocket-server-on-elastic-beanstalk&#34;&gt;CLOJURE WEBSOCKET SERVER ON ELASTIC BEANSTALK&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://inokara.hateblo.jp/entry/2013/12/29/215322&#34;&gt;Dockerfile の書き方「私的」なベストプラクティス（3）〜サービスの起動について〜&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Lobosでマイグレーションができない in Heroku</title>
          <link>http://yet.unresolved.xyz/blog/2014/12/21/does-not-work-lobos-in-heroku/</link>
          <pubDate>Sun, 21 Dec 2014 00:00:00 UTC</pubDate>
          <author>Daisuke Tsuji</author>
          <guid>http://yet.unresolved.xyz/blog/2014/12/21/does-not-work-lobos-in-heroku/</guid>
          <description>

&lt;p&gt;ClojureのWebアプリがとりあえず動くところまで行ったんだけど、Herokuにのせようとしたら詰まった。&lt;/p&gt;

&lt;h2 id=&#34;何が起きたか:b3814854ab9c35505a0d42182d51f32f&#34;&gt;何が起きたか&lt;/h2&gt;

&lt;p&gt;今だにHerokuの使い方がようわからんのだけど、&lt;/p&gt;

&lt;p&gt;とりあえずローカルから向き先変えるよりもSSHの方がいっかなってことで&lt;code&gt;heroku run bash&lt;/code&gt;してやってます。&lt;/p&gt;

&lt;p&gt;ローカルからだとDBをSSLで接続させないといけないし・・・。&lt;/p&gt;

&lt;p&gt;んでマイグレーションしようとしたら、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure-repl&#34;&gt;user=&amp;gt; (migrate)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何も出ない。&lt;/p&gt;

&lt;p&gt;本当はこんな感じで、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure-repl&#34;&gt;user=&amp;gt; (migrate)
add-sites-table
add-entries-table
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作成されたり変更されたテーブルが出てくるはず。&lt;/p&gt;

&lt;h2 id=&#34;原因はなんだったのか:b3814854ab9c35505a0d42182d51f32f&#34;&gt;原因はなんだったのか&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;lobos.migrations&lt;/code&gt;が読まれてない（というかリロードされてない）っぽい。&lt;/p&gt;

&lt;p&gt;そもそも&lt;code&gt;migrate&lt;/code&gt;自体はこんな感じで&lt;code&gt;lobos.migration&lt;/code&gt;の&lt;code&gt;do-migrations&lt;/code&gt;を呼んでます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defcommand migrate [&amp;amp; names]
  (let [names (if (empty? names)
                (mig/pending-migrations db-spec sname)
                names)]
    (mig/do-migrations db-spec sname :up names)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、&lt;code&gt;do-migrations&lt;/code&gt;はこんな感じで、&lt;code&gt;list-migrations-names&lt;/code&gt;の結果を絞って実行してる。&lt;/p&gt;

&lt;p&gt;たぶんマイグレーション済みのものは除外とかそんな感じなんじゃないだろうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn do-migrations [db-spec sname with names &amp;amp; [silent]]
  (let [filter-migs #(only % (list-migrations-names))
        migrations (-&amp;gt;&amp;gt; names
                        (map str)
                        filter-migs
                        (when-&amp;gt;&amp;gt; (= with :down) reverse)
                        (map symbol)
                        (map (partial ns-resolve *migrations-namespace*))
                        (map var-get))]
    (binding [*record* nil]
      (doseq [migration migrations]
        (let [name (-&amp;gt; migration meta :name)]
          (when-not silent
            (println name))
          (if (= with :up)
            (do
              (up migration)
              (insert-migrations db-spec sname name))
            (do
              (down migration)
              (delete-migrations db-spec sname name))))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で&lt;code&gt;list-migrations-names&lt;/code&gt;の定義がこれ、&lt;code&gt;list-migrations&lt;/code&gt;を呼んでる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn list-migrations-names []
  (map #(-&amp;gt; % meta :name str) (list-migrations)))

(defn list-migrations []
  (if *reload-migrations*
    (when (.exists (migrations-file))
      (swap! migrations (constantly []))
      (use :reload *migrations-namespace*)
      @migrations)
    @migrations))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この&lt;code&gt;list-migrations&lt;/code&gt;が問題のようで、いや、たぶんHeroku側の環境がよくないんだと思うけど、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;      (use :reload *migrations-namespace*)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この&lt;code&gt;:reload&lt;/code&gt;が正常に動かなくてマイグレーション対象が取れてない。&lt;/p&gt;

&lt;p&gt;だから&lt;code&gt;list-migrations&lt;/code&gt;を実行した時、1回目はきちんとロードされて、&lt;/p&gt;

&lt;p&gt;2回目は&lt;code&gt;(swap! migrations (constantly []))&lt;/code&gt;で空っぽになったままリロードされてないのが悪かったみたい。&lt;/p&gt;

&lt;p&gt;だからこんな風に、2回目の実行からは空になった&lt;code&gt;migrations&lt;/code&gt;が返ってくる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure-repl&#34;&gt;user=&amp;gt; (use &#39;lobos.migration)
WARNING: complement already refers to: #&#39;clojure.core/complement in namespace: user, being replaced by: #&#39;lobos.migration/complement
nil
user=&amp;gt; (list-migrations)
[#&amp;lt;migrations$reify__2390 lobos.migrations$reify__2390@445aed&amp;gt; #&amp;lt;migrations$reify__2392 lobos.migrations$reify__2392@42bfb95d&amp;gt;]
user=&amp;gt; (list-migrations)
[]
user=&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;解決策:b3814854ab9c35505a0d42182d51f32f&#34;&gt;解決策&lt;/h2&gt;

&lt;p&gt;もう正直ここまでで一週間弱悩んだから、lobos使うのやめようかなとも思ったけどまあいい勉強だろうし・・・。&lt;/p&gt;

&lt;p&gt;暫定にしかならないけど、とりあえずリロードさせないようにしよう。&lt;/p&gt;

&lt;p&gt;ソースコードの通り、&lt;code&gt;*reload-migrations*&lt;/code&gt;が&lt;code&gt;true&lt;/code&gt;になっている場合にリロードが走るらしい。&lt;/p&gt;

&lt;p&gt;だからこんな感じで&lt;code&gt;false&lt;/code&gt;で上書いてしまおう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure-repl&#34;&gt;user=&amp;gt; (use &#39;lobos.migration)
WARNING: complement already refers to: #&#39;clojure.core/complement in namespace: user, being replaced by: #&#39;lobos.migration/complement
nil
user=&amp;gt; (ns lobos.migration)

IllegalStateException defonce already refers to: #&#39;lobos.utils/defonce in namespace: lobos.migration  clojure.lang.Namespace.warnOrFailOnReplace (Namespace.java:88)
user=&amp;gt; (def ^{:dynamic true} *reload-migrations* false)
#&#39;lobos.migration/*reload-migrations*
lobos.migration=&amp;gt; (use &#39;lobos.core)
WARNING: alter already refers to: #&#39;clojure.core/alter in namespace: lobos.migration, being replaced by: #&#39;lobos.core/alter
WARNING: drop already refers to: #&#39;clojure.core/drop in namespace: lobos.migration, being replaced by: #&#39;lobos.core/drop
nil
lobos.migration=&amp;gt; (migrate)
add-sites-table
add-entries-table
nil
lobos.migration=&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これじゃない感がすごいけど、とりあえず通った・・・。&lt;/p&gt;

&lt;p&gt;Lobosはもう開発があんまり活発じゃないみたいだなあ。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;lobos.migration&lt;/code&gt;と&lt;code&gt;lobos.migrations&lt;/code&gt;の命名はちょっといけてないような・・・。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Lobosを使ってマイグレーションをする</title>
          <link>http://yet.unresolved.xyz/blog/2014/12/11/usage-for-lobos-migration/</link>
          <pubDate>Thu, 11 Dec 2014 00:00:00 UTC</pubDate>
          <author>Daisuke Tsuji</author>
          <guid>http://yet.unresolved.xyz/blog/2014/12/11/usage-for-lobos-migration/</guid>
          <description>

&lt;p&gt;1年前くらいには、SQLまで隠蔽するORMとか嫌い！テーブルの自動生成やだ！とか言ってたのに、いつの間にかスキーマ操作なんてフレームワークがやるものだよね、って考えになってしまったよ・・・。&lt;/p&gt;

&lt;p&gt;というわけでClojureを使ってWeb開発をする際も使いたいので、Lobosというスキーマのマニュピレーション、マイグレーションツールを使ってみます。&lt;/p&gt;

&lt;h2 id=&#34;インストール:a4d3af33140cffc65cf5c9a1e4293067&#34;&gt;インストール&lt;/h2&gt;

&lt;p&gt;本体はここ&lt;a href=&#34;https://github.com/budu/lobos&#34;&gt;budu/lobos&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;project.clj&lt;/code&gt;に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;:dependencies [[lobos &amp;quot;1.0.0-beta3&amp;quot;]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追加して&lt;code&gt;lein deps&lt;/code&gt;するだけでおーけー。&lt;/p&gt;

&lt;p&gt;Leiningenのプラグインとして使える&lt;a href=&#34;https://github.com/pupeno/lein-lobos&#34;&gt;pupeno/lein-lobos&lt;/a&gt;ってのもあるようだ。&lt;/p&gt;

&lt;p&gt;こっちも使う場合は、&lt;code&gt;ploject.clj&lt;/code&gt;に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;:plugins [lein-lobos &amp;quot;1.0.0-beta1&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追加。&lt;/p&gt;

&lt;p&gt;全体を載っけるとこんな感じに。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(defproject tpc &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  :description &amp;quot;FIXME: write description&amp;quot;
  :url &amp;quot;http://example.com/FIXME&amp;quot;
  :min-lein-version &amp;quot;2.0.0&amp;quot;
  :dependencies [[org.clojure/clojure &amp;quot;1.6.0&amp;quot;]
                 [compojure &amp;quot;1.2.0&amp;quot;]
                 [ring/ring-defaults &amp;quot;0.1.2&amp;quot;]
                 [enlive &amp;quot;1.1.5&amp;quot;]
                 [korma &amp;quot;0.4.0&amp;quot;]
                 [postgresql &amp;quot;9.1-901.jdbc4&amp;quot;]
                 [lobos &amp;quot;1.0.0-beta3&amp;quot;]]
  :plugins [[lein-ring &amp;quot;0.8.13&amp;quot;]
            [lein-haml-sass &amp;quot;0.2.7-SNAPSHOT&amp;quot;]
            [lein-lobos &amp;quot;1.0.0-beta1&amp;quot;]]
  :ring {:handler tpc.core.handler/app}
  :profiles
  {:dev {:dependencies [[javax.servlet/servlet-api &amp;quot;2.5&amp;quot;]
                        [ring-mock &amp;quot;0.1.5&amp;quot;]
                        [org.xerial/sqlite-jdbc &amp;quot;3.6.16&amp;quot;]]}}
  :scss {:src &amp;quot;resources/scss&amp;quot;
         :output-directory &amp;quot;resources/public/css&amp;quot;
         :output-extension &amp;quot;css&amp;quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;テーブル定義をしてみる:a4d3af33140cffc65cf5c9a1e4293067&#34;&gt;テーブル定義をしてみる&lt;/h2&gt;

&lt;p&gt;今回はSQLiteにて実施。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src&lt;/code&gt;ディレクトリ直下に&lt;code&gt;lobos&lt;/code&gt;ってディレクトリを作成して、その中にいろいろな設定を突っ込む必要があるらしい。&lt;/p&gt;

&lt;p&gt;このディレクトリの名前は変えてもいいみたいだけど面倒になりそうだからこのままで。&lt;/p&gt;

&lt;p&gt;まずは接続情報を記載する&lt;code&gt;src/lobos/config.clj&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(ns lobos.config
  (:use lobos.connectivity))

(def db_dev
     {:classname &amp;quot;org.sqlite.JDBC&amp;quot;
      :subprotocol &amp;quot;sqlite&amp;quot;
      :subname &amp;quot;./dev.sqlite3&amp;quot;})

(open-global db_dev)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次にスキーマ操作で使われている(と思われる)ヘルパー、&lt;code&gt;src/lobos/helpers.clj&lt;/code&gt;を定義。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(ns lobos.helpers
  (:refer-clojure :exclude [bigint boolean char double float time])
  (:use (lobos schema)))

(defn surrogate-key [table]
  (integer table :id :auto-inc :primary-key))

(defn timestamps [table]
  (-&amp;gt; table
      (timestamp :updated_on)
      (timestamp :created_on (default (now)))))

(defn refer-to [table ptable]
  (let [cname (-&amp;gt; (-&amp;gt;&amp;gt; ptable name butlast (apply str))
                  (str &amp;quot;_id&amp;quot;)
                  keyword)]
    (integer table cname [:refer ptable :id :on-delete :set-null])))

(defmacro tbl [name &amp;amp; elements]
  `(-&amp;gt; (table ~name)
       (timestamps)
       ~@(reverse elements)
       (surrogate-key)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、目的のマイグレーション定義を&lt;code&gt;src/lobos/migrations.clj&lt;/code&gt;に。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(ns lobos.migrations
  (:refer-clojure :exclude [alter drop
                            bigint boolean char double float time])
  (:use (lobos [migration :only [defmigration]] core schema
               config helpers)))

(defmigration add-sites-table
  (up [] (create
          (tbl :sites
            (varchar :name 255)
            (varchar :url 255)
            (varchar :rss 255)
            (varchar :image 255)
            (integer :cat)
            )))
  (down [] (drop (table :sites))))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;マイグレーションの実行:a4d3af33140cffc65cf5c9a1e4293067&#34;&gt;マイグレーションの実行&lt;/h2&gt;

&lt;p&gt;ここが結構厄介だった。&lt;/p&gt;

&lt;p&gt;というか、出来たといえば出来たんだけど、もっと正しい方法があるような気が・・・。&lt;/p&gt;

&lt;p&gt;REPLにて以下を実行。&lt;/p&gt;

&lt;p&gt;WARNINGは多分すでに存在するシンボルを置き換えてしまってることの警告だからとりあえず無視。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure-repl&#34;&gt;tpc git:(master)$ lein repl
(use &#39;(lobos connectivity core schema))nREPL server started on port 50092 on host 127.0.0.1 - nrepl://127.0.0.1:50092
REPL-y 0.3.1
Clojure 1.6.0
    Docs: (doc function-name-here)
          (find-doc &amp;quot;part-of-name-here&amp;quot;)
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=&amp;gt; (use &#39;(lobos connectivity core schema))
WARNING: alter already refers to: #&#39;clojure.core/alter in namespace: user, being replaced by: #&#39;lobos.core/alter
WARNING: drop already refers to: #&#39;clojure.core/drop in namespace: user, being replaced by: #&#39;lobos.core/drop
WARNING: boolean already refers to: #&#39;clojure.core/boolean in namespace: user, being replaced by: #&#39;lobos.schema/boolean
WARNING: char already refers to: #&#39;clojure.core/char in namespace: user, being replaced by: #&#39;lobos.schema/char
WARNING: double already refers to: #&#39;clojure.core/double in namespace: user, being replaced by: #&#39;lobos.schema/double
WARNING: bigint already refers to: #&#39;clojure.core/bigint in namespace: user, being replaced by: #&#39;lobos.schema/bigint
WARNING: float already refers to: #&#39;clojure.core/float in namespace: user, being replaced by: #&#39;lobos.schema/float
WARNING: time already refers to: #&#39;clojure.core/time in namespace: user, being replaced by: #&#39;lobos.schema/time
nil
user=&amp;gt; (require &#39;lobos.migrations)
nil
user=&amp;gt; (migrate)
add-sites-table
nil
user=&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;確認してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;tpc git:(master)$ sqlite3 dev.sqlite3
SQLite version 3.8.5 2014-08-15 22:37:57
Enter &amp;quot;.help&amp;quot; for usage hints.
sqlite&amp;gt; .tables
lobos_migrations  sites
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;できてる！&lt;/p&gt;

&lt;p&gt;まだまだ名前空間とか&lt;code&gt;require&lt;/code&gt;あたりの理解が甘いなー・・・。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>LeiningenでSCSSを自動コンパイルする</title>
          <link>http://yet.unresolved.xyz/blog/2014/12/09/automatically-compile-the-scss-in-leiningen/</link>
          <pubDate>Tue, 09 Dec 2014 00:00:00 UTC</pubDate>
          <author>Daisuke Tsuji</author>
          <guid>http://yet.unresolved.xyz/blog/2014/12/09/automatically-compile-the-scss-in-leiningen/</guid>
          <description>

&lt;p&gt;Clojureを始めて一週間ほどになりまして。&lt;/p&gt;

&lt;p&gt;ようやくWebアプリ開発に着手しました。&lt;/p&gt;

&lt;p&gt;というわけで開発環境を整えます。&lt;/p&gt;

&lt;h2 id=&#34;lein-haml-sassの導入:aea6c6aa18698925cad2fc33bce27d8b&#34;&gt;lein-haml-sassの導入&lt;/h2&gt;

&lt;p&gt;まったく贅沢な名前してんな！&lt;/p&gt;

&lt;p&gt;いえ、&lt;a href=&#34;https://github.com/rtircher/lein-haml-sass&#34;&gt;lein-haml-sass&lt;/a&gt;は素晴らしいプラグインです。&lt;/p&gt;

&lt;p&gt;これを使うとなんとhamlのコンパイルやsass/scssのコンパイルをやってくれます。&lt;/p&gt;

&lt;p&gt;ていうか&lt;strong&gt;sassとscssの違い&lt;/strong&gt;ってなんだっけ？真面目に考えるとわかんないな。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.atmarkit.co.jp/ait/articles/1402/17/news102.html#02&#34;&gt;CSSコーディングで泣かないためのSassの基礎知識と10の利点 (&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt;)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;へえ・・・。&lt;/p&gt;

&lt;p&gt;とりあえず導入します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;project.clj&lt;/code&gt;に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(defproject example &amp;quot;1.2.3&amp;quot;
  :plugins [[lein-haml-sass &amp;quot;0.2.7-SNAPSHOT&amp;quot;]])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらに設定も記述。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;resources/sass/&lt;/code&gt;にscssを、&lt;code&gt;resources/public/css/&lt;/code&gt;にcssを出力する設定。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(defproject example-project &amp;quot;1.2.3&amp;quot;
  :haml {:src &amp;quot;resources/haml&amp;quot;
         :output-directory &amp;quot;resources/public/html&amp;quot;
         }

  :sass {:src &amp;quot;resources/sass&amp;quot;
         :output-directory &amp;quot;resources/public/css&amp;quot;
         }

  :scss {:src &amp;quot;resources/scss&amp;quot;
         :output-directory &amp;quot;resources/public/css&amp;quot;
         }
    )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここまではコピペだけど、オレのファイル自体はこんな感じに。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(defproject tpc &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  :description &amp;quot;FIXME: write description&amp;quot;
  :url &amp;quot;http://example.com/FIXME&amp;quot;
  :min-lein-version &amp;quot;2.0.0&amp;quot;
  :dependencies [[org.clojure/clojure &amp;quot;1.6.0&amp;quot;]
                 [compojure &amp;quot;1.2.0&amp;quot;]
                 [ring/ring-defaults &amp;quot;0.1.2&amp;quot;]
                 [enlive &amp;quot;1.1.5&amp;quot;]]
  :plugins [[lein-ring &amp;quot;0.8.13&amp;quot;]
            [lein-haml-sass &amp;quot;0.2.7-SNAPSHOT&amp;quot;]]
  :ring {:handler tpc.core.handler/app}
  :profiles
  {:dev {:dependencies [[javax.servlet/servlet-api &amp;quot;2.5&amp;quot;]
                        [ring-mock &amp;quot;0.1.5&amp;quot;]]}}
  :scss {:src &amp;quot;resources/sass&amp;quot;
         :output-directory &amp;quot;resources/public/css&amp;quot;
         :output-extension &amp;quot;css&amp;quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;コンパイルする:aea6c6aa18698925cad2fc33bce27d8b&#34;&gt;コンパイルする&lt;/h2&gt;

&lt;p&gt;さっそく&lt;code&gt;lein sass once&lt;/code&gt;してみるも、何も起きない！&lt;/p&gt;

&lt;p&gt;あっ、sassとscssでタスクが違う。&lt;/p&gt;

&lt;p&gt;ていうかsassフォルダにscss置くのってなんか違う気がしてきた！あとで名前変えよう。&lt;/p&gt;

&lt;p&gt;というわけで、&lt;code&gt;lein scss once&lt;/code&gt;で無事動きました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;lein scss auto&lt;/code&gt;で変更監視できるっぽい。&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
